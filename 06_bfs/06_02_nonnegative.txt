============================== Step 2 ==============================
Взвешенные графы: простейшие замечания

любой подпуть кратчайшего пути является кратчайшим

s ~~~~*~~~~~~~~~*~~~~~> v
      u~~~~~~~>w

если s → ... → u → v — кратчайший путь из s в v, 
то dist(s, v) = dist(s, u) + w(u, v)
в данном случае dist это функция, а не массив, как раньше

s ~~~~~~~~~~~~~~*~~~~> v
                u
dist(s, v) - длина кратчайшего пути
w(u, v) - вес ребра u-v

============================== Step 3 ==============================
Релаксация ребра

процедура Relax((u,v)∈E)
если dist[v]>dist[u]+w(u,v): 
  dist[v ] ← dist[u] + w (u, v ) 
  prev[v] ← u

============================== Step 4 ==============================
Перебор вершин в порядке увеличения расстояния

s ~~~~~~~~~~*~~~~~~~~> v
	    u

Хотелось бы перебирать вершины в порядке удаления от s.

============================== Step 7 ==============================
Алгоритм Дейкстры

процедура Dijkstra(G,s)
для всех вершин u∈V: 
  dist[u] ← ∞
  prev[u] ← nil
dist[s] ← 0
H ← MakeQueue(V ) {dist в качестве ключей} 
пока H не пусто:
  u ← ExtractMin(H)
  для всех рёбер (u,v) ∈ E:
  если dist[v] > dist[u] + w(u,v): 
    dist[v ] ← dist[u] + w (u, v ) 
    prev[v] ← u
    ChangePriority(H , v , dist[v])

Последовательно расширяем множество вершин, расстояние до которых мы
уже знаем

============================== Step 8 ==============================

Время работы
                 кол-во релаксаций
|V| * T(extractmin) + |E| * T(ChangePriority)

Реализация очереди
1) Массив: |V| * O(|V|) + |E| * O(1) = O(|V|^2) (если граф плотный
(ребер почти V^2), то
линейное время)
2) Двоичная куча: O(|V| + |E|) * log|V| (если граф не плотный, то этот
быстрее, иначе первый)
3) d-чная куча (у каждой вершины d детей): 
|V| * d * log_{d} |V| + |E| log_{d} |V| = 
= O(|V| * d + |E|) * (log{d} |V|)

Как выбрать d:
d = |E| / |V|
тогда O(|E|) log_{|E| / |V|} |V|

1) граф плотный, тогда |E| = THETA(|V|^2), тогда время линейное
2) граф разреженный, тогда E = O(|V|), тогда |V| log |V|
3) промежуточный вариант, тогда E = THETA(|V|^1.5), тогда время работы
линейное от количества ребер

============================== Step 9 ==============================
Задача на программирование. Дан ориентированный взвешенный граф на n
вершинах и m рёбрах (1≤n≤1000, 0≤m≤100000). Вес ребра — натуральное
число, не превышающее 1000. Последняя строка содержит номера двух
вершин u и v. Выведите кратчайшее расстояние между вершинами u и v или
-1, если в графе нет пути из u в v.

Sample Input:
4 4
1 2 1
4 1 2
2 3 2
1 3 5
1 3

Sample Output:
3

Memory Limit: 256 MB
Time Limit: 5 seconds 

Source: dijkstra.py

============================== Step 10 ==============================
Задача на peer-review. Дан сильно связный ориентированный граф G=(V,E)
с положительными весами на рёбрах и вершина v0∈V. Мы хотим для всех
пар вершин найти кратчайшие расстояния среди путей, проходящих через
v0. Постройте алгоритм, решающий данную задачу за O(|V|2).

Source: dijkstra_peer.txt
