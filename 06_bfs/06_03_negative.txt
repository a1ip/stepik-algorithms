============================== Step 2 ==============================
Тест. Что не так в следующем алгоритме нахождения кратчайшего пути из
s в t в данном ориентированном графе, содержащем рёбра отрицательного
веса? Прибавим достаточно большую константу к весам всех рёбер и
сделаем все веса положительными, после чего воспользуемся алгоритмом
Дейкстры.

Ответ: После изменения весов рёбер кратчайшие пути между вершинами
могли измениться: кратчайший путь между s и t в новом графе не
обязательно будет кратчайшим и в старом графе. 

============================== Step 4 ==============================

процедура BellmanFord(G,s)
{в G нет циклов отрицательного веса}
для всех вершин u∈V: 
  dist[u] ← ∞
  prev[u] ← nil
dist[s] ← 0
повторить |V|−1 раз:
  для всех рёбер (u,v) ∈ E: 
    Relax(u,v)

Время работы O(|V|*|E|)

============================== Step 6 ==============================
Циклы отрицательного веса

Лемма

Цикл отрицательного веса есть тогда и только тогда, когда на |V |-й
итерации алгоритма Беллмана–Форда изменяется значение dist хотя бы для
одной вершины.

============================== Step 7 =============================

Задача на программирование. Дан взвешенный ориентированный граф на n
вершинах и m рёбрах (1≤n≤1000, 0≤m≤10000). Вес ребра — целое число, по
модулю не превышающее 1000. Выведите 1, если в графе есть цикл
отрицательного веса, и 0 в противном случае.

Sample Input:
4 4
1 2 1
4 1 2
2 3 2
3 1 -5

Sample Output:
1

Source: bf.py

============================== Step 8 ==============================
Кратчайшие пути в ациклических графах

процедура DagShortestPaths(G,s)
для всех вершин u∈V: 
  dist[u] ← ∞
  prev[u] ← nil
dist[s] ← 0
топологически упорядочить G
для всех u ∈ V в найденном порядке:
  для всех рёбер (u,v) ∈ E: 
    Relax(u,v)

============================== Step 9 ==============================
Задача на программирование повышенной сложности. Дан ориентированный
взвешенный граф и вершина s в нем. Требуется для каждой вершины u
найти длину кратчайшего пути из s в u.

Первая строка содержит три числа n, m и s (1≤s≤n≤1000,0≤m≤10000) —
количество вершин, рёбер и стартовая вершина,
соответственно. Следующие m строк содержат описание ребер графа (граф
может содержать кратные рёбра). Вес ребра по модулю не превосходит 109
(веса — целые числа). Для каждой вершины u в отдельной строке
выведите:

    *, если в графе нет пути из s в u;
    -, если путь из s в u есть, но кратчайшего пути из s в u нет;
    длину кратчайшего пути из s в u, если такой пусть есть.

Sample Input:
6 7 1
1 2 10
2 3 5
1 3 100
3 5 7
5 4 10
4 3 -18
6 1 -1

Sample Output:
0
10
-
-
-
*

Memory Limit: 256 MB
Time Limit: 10 seconds 

============================== Step 10 ==============================
Задача повышенной сложности для самостоятельной проверки. Постройте
алгоритм, определяющий, содержит ли данный неориентированный граф
G=(V,E) простой цикл (то есть цикл без самопересечений) длины 4, за
время 
    O(|V|^3);
    O(|V|^2).

