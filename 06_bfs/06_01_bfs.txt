============================== Step 4 ==============================

Поиск в ширину

процедура BFS(G,s)
{Вход: граф G(V,E), вершина s ∈ V.}
{Выход: для всех вершин u, достижимых из s, 
dist[u] будет равно расстоянию от s до u.}

для всех вершин u∈V: dist[u] ← ∞
  dist[s] ← 0
Q ← {s} {очередь из одного элемента} 

пока Q не пусто:
  u ← Eject(Q)
  для всех рёбер (u,v) ∈ E:
    если dist[v] = ∞: 
      Inject(Q , v )
      dist[v] ← dist[u] + 1

============================== Step 5 ==============================
Дерево кратчайших путей (minimum spanning tree)

dist = [S, A, B, C, D, E]
       [0, 1, 2, 1, 1, 1]

dist[v] = dist[u] + 1
pred[v] = u // массив предыдущих вершин

dist = [0, 1, 2, 1, 1, 1]
prev = [_, S, A, S, S, S] - по этому массиву можно восстановить
людей кратчайший путь  -- от S до любой другой вершины

Например, чтобы понять кратчайший путь из S в B, надо:
1) выписываем вершину B последней
2) посмотреть в массиве prev какая предпоследняя вершина на кратчайшем
пути: это вершина A (prev[B])
3) какая следующая вершина, тоже смотрим в prev: (prev[A] = S)
4) пришли в S -- путь найден: S, A, B

============================== Step 6 ==============================
Задача на программирование. Дан неориентированный граф на n вершинах и
m рёбрах (1≤n,m≤100000), а также номера вершин u и v. Выведите
количество рёбер на кратчайшем пути между вершинами u и v или -1, если
пути между ними в графе нет.

Sample Input:
4 4
1 2
4 1
2 3
3 1
2 4

Sample Output:
2

Memory Limit: 256 MB
Time Limit: 5 seconds 

Source: shortest_path.py
