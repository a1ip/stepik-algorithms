Сортировка и поиск, Step 14
Метод двух указателей

Алгоритм для поиска трех элементов упорядоченного массива, в сумме
дающих ноль: можно записать в псевдокоде следующим образом:

процедура SumOfThreeWithPointers(A[1..n])
{массив А упорядочен}

для всех x от 1 до n:
    i <- A[x];
    l <- x + 1; # левый указатель
    r <- n; # правый указатель
    пока l < r:
    	 j = A[l];
	 k = S[r];
	 если (i + j + k == 0): вернуть i, j, k;
	 иначе если (i + j + k > 0): r <- r - 1;
	 иначе если (i + j + k < 0): l <- l + 1;
вернуть -1; # если тройки, дающей в сумме 0 нет
    
Скороть работы алгоритма в худшем случае составит $O(n^2)$, поскольку
мы имеем дело с двумя вложенными циклами. Внешний цикл перебирает n
элементов, а вложенный в худшем случае n - 1, итого $n(n - 1)$
переборов, что по правилам О-нотации дает приближенную оценку роста
функции $O(n^2)$.

Доказательство корректности работы алгоритма аналогично доказательству
алгоритма метода двух указателей (Сортировка и поиск, Step 14):
входной массив упорядочен, указатель i всегда начинается с первого
эдемента массиваа, а указатели l и r двигаются только в одну сторону -
навстречу друг другу. Поэтому указатели обязательно наткнутся либо на
j, либо на k. После натыкания на первый из указателей, алгоритм
продолжает смещение, пока не наткнется на последний указатель.
Возможен вариант, когда нужная нам тройка не существует - в этом
случае алгоритм возвращает -1.
