============================== Step 4 ==============================
Графы состоят из вершин V (vertices, nodes) и ребер E (edges, arcs)

Граф с ориентированными ребрами (directed graph)
V ={A,B,C,D}
E = {(A,B),(C,D),(C,A),(B,C)}

Граф с неориентированными ребрами (undirected graphs)
V ={A,B,C,D}
E = {({A,B},3),({A,D},1), ({B,D},2),({C,D},−1),({A,C},2)}

({A,B},3 - ребро из A в B и его вес

============================== Step 5 ==============================

Как хранить графы

(A)->(B)
 \   </
  >(C)

1) Список ребер
(А, B) -> (B, C) -> (A, C)

В памяти занимаем O(|V| + |E|)

Проверка наличия ребра? Время O(|E|)

Перебор соседей конкретной вершины: O(|E|)

2) Матрица смежности
  A B C
A 0 1 1
B 0 0 1
C 0 0 0 

Если бы граф был неоринетированный, то матрица была бы симметрической

O(|V|^2) - место в памяти. Очень расточительно для крупных матриц с малым количеством связей.

Проверка наличия ребра? Легко -- просто смотрим нужную ячейку массива за O(1)
Если это востребованная операция -- надо исползовать эту структуру

Перебор соседей конкретной вершины: O(|V|)

3) Список смежности (самое оптимальное для наших задач)
-----
A|B|C
-----
| |
B C
|
C

В памяти занимаем O(|V| + |E|)

Если бы граф был неориентированным, то в каждой вершине было бы по два узла

Проверка наличия ребра? Время O(d), d степень вершины, т.е количество вершин, с которой она соединена

Перебор соседей конкретной вершины: O(d) - оптимально

============================== Step 6 ==============================

В задачах на программирование графы задаются следующим образом. Первая
строка содержит числа n и m — количества вершин и рёбер в графе
соответственно. Предполагается, что вершины графа пронумерованы
числами от 1 до n. Каждая из последующих строк входа задаёт очередное
ребро графа в формате u v, где 1≤u,v≤n — номера вершин графа. Если в
задаче речь идёт о неориентированном графе, то таким образом задаётся
ребро, соединяющее вершины u и v. Если же граф ориентированный, то
задаётся ребро из u в v. Если граф взвешенный, то ребро задаётся
тройкой u v w, где u и v, как и прежде, обозначают начало и конец
ребра, а w — его вес.

Пример задания ориентированного взвешенного графа:

4 5
3 4 -1
1 3 2
1 2 3
2 4 2
1 4 1

============================== Step 7 ------------------------------
Все утверждения верны:

Список смежности более экономен по памяти, чем матрица смежности.

Для плотных графов (|E|=Ω(|V2|)) список смежности и матрица смежности
требуют Θ(|V|2) памяти. 

Вычислить степени всех вершин в графе, заданном списком смежности,
 можно за O(|V|+|E|). 

Список всех соседей вершины графа, заданного списком смежности, можно
найти за время, пропорциональное длине списка. 

Если граф задан матрицей смежности, можно за O(1) проверить, соединены
ли две вершины ребром.

