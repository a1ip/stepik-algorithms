============================== Step 2 ==============================
Компоненты сильной связности это такие куски графа, внутри которых
любая вершина достижима из любой другой.

Нужно использовать два поиска DFS, т.е. алгоритм по-прежнему линейное
время работает. 

============================== Step 3 ==============================
Пример со слайда 2/6
В вершину С невозможно добраться ни из какой другой вершины, потому
что в нее нет входящих ребер. Поэтому граф несвязанный.

Если для двух вершин графа из первой во вторую есть путь и наоборот,
то это отношения эквивалентности. 

Две вершины попадают в один и тот же кусок (компонент связанности),
если из одной есть путь во вторую и наоборот.

На слайде 2/6 есть, например, такой очевидный кусок с вершинами F, G,
K

Второй кусок: B, H, D, I, A

Третий кусок: С
Четвертый кусок: E

============================== Step 4 ==============================
Сколько компонент сильной связности в графе ниже?

Source: 05_04_04.png

Answer: 5
1) B
2) A
3) E
4) G, H, I
5) C, D, F, J

============================== Step 5 ==============================
Метаграф -- он же граф компонент сильной связности (или конденсация)

Может быть удобно сначала построить метаграф, чтобы решить какой-то
вопрос достижимости. Есть алгоритмы, которые его строят за линейное
время. 

1) Метаграф является **ациклическим**!

Значит, что его можно засунуть в топосорт

2) В метаграфе есть **сток**!
Сток -- элемент, из которого нет никаких выходных ребер

Если из стока запустить explore, то обойдется ровно одна компонента, в
которой принадлежит сток -- и никуда за пределы этой компоненты мы не
выйдем!

Далее, если бы мы запустили explore для E, то тоже обошли бы одну
компоненту связности. 

Далее, пусть D -- для нее explore нашла бы новые элементы, которые
относятся к следующей компоненте связности. (Конечно, explore
попыталась бы перейти в E, но там мы уже были. А все новые открытые
explore вершины относились бы к новой компоненте)

Аналогично с C.

Порядок вызова explore должен быть такой: K, E, D, C

Как его найти?

============================== Step 6 ==============================
Лемма

Пусть C и C′ — компоненты сильной связности графа и в графе есть
ориентированное ребро из C в C′. Тогда максимальное время окончания
обработки вершин в C больше, чем максимальное время окончания
обработки вершин в C′.

[C]--->[C']

Тогда C.finished >  C'.finished,
то есть сравниваем самые поздние времена конца обработки вершин в C и
C'

1) сначала DFS наткнулся на вершину в C.
В какой-то момент поиск обязательно перейдет в вершину из C'.
Значит, пока он не обойдет все вершины С', он не закончит все вершины
в C', он не закончит обрабатывать C и  C.finished >  C'.finished
выполняется.

2) Если сначала наткнулся на C'.
Он не сможет перейти в C, потому что иначе они были бы одной
компонентой.

============================== Step 7 ==============================
Транспонированный граф

Если запустить DFS и посмотреть на вершину с самым поздним временем
finished, то принадлежать она будет компоненте истоку в метаграфе (то
есть из этой компоненты ребра могут только ВЫХОДИТЬ, входить туда
ничего не будет)

Транспонированный граф (G^R) -- это граф, у которого все ребра
обращены!

По списку смежности графа G можно построить список смежности
транспонированного гравфа G^R за линейное время.

Идем по исходному списку смежности, видим, например, ребро B->C, то
добавляем в список смежности транспонированного графа ребро C->B

То есть построение занимает линейное время

Теперь запускаем DFS для транспонированного графа. И находит вершину с
самым поздним временем завершения finished, то эта вершина будет
принадлежать компоненте-истоку. А эта компонента в начальном графе
является компонентой-стоком!

Поэтому теперь можем из нее запуститься и обойти всю компоненту!

Пример для слайда 5/6
1) Запускаем DFS для транспонированного графа
Запускаем в А

А->I->C

C


C->D->H->B

C B

B->H

C B H

H->D

C B H D

D->I

C B H D I

D-> A
C B H D I A

E->
C B H D I A E

F->G->K

C B H D I A E K G F

2) Идем по полученном списку справа налево: C B H D I A E K G F
Запускаем explore сначала для F: обойдется первая компонента
G, K, в визитед, поэтому запускаем explore для E
Теперь запускаем для A -> получаем компонентку
И наконец для С - последняя компонента

Очень похоже на поиск компонент связности для неориентированных графов

============================== Step 7 ==============================

процедура SCC(G)

вызвать поиск в глубину для GR

вызвать алгоритм нахождения компонент связности
в неориентированных графах, перебирая в поиске в
глубину вершины в порядке убывания времён конца
обработки, найденных на первом шаге

То есть:
1) Строим GR (линейное время)

2) запускаем DFS для GR, параллельно выписывая вершины, когда
заканчивается их обработка! (получаем список в котором они идут в
порядке возрастания окончания обработки)

3) запускаем DFS на исходном G, но перебираем вершины не в
произвольном порядке, а в порядке убывания времени окончания (т.е. в
инвертированном списке шага 2)

4) После каждого внешнего запуска explore из DFS увеличивать счетчик
текущей компоненты

============================== Step 8 ==============================
Задача на программирование. Дан ориентированный граф на n вершинах и m
рёбрах (1≤n≤100000, 0≤m≤100000). Выведите количество компонент сильной
связности в данном графе.

Sample Input:
4 4
1 2
4 1
2 3
3 1

Sample Output:
2

Source: scc.py

============================== Step 10 ==============================
Задача для самостоятельной проверки. Ориентированный граф называется
полусвязным, если для любых его двух вершин u и v в графе есть или
путь из u в v, или путь из v в u (или оба). Постройте алгоритм,
проверяющий, является ли входной граф G=(V,E) полусвязным, за время
O(|V|+|E|). 

============================== Step 11 ==============================
Задача повышенной сложности для самостоятельной проверки. Входом
задачи 2-выполнимости является конъюнкция дизъюнктов, каждый из
которых является дизъюнкцией двух литералов, где литерал -- это булева
переменная или её отрицание. Требуется выяснить, можно ли всем
переменным формулы присвоить значения 𝚝𝚛𝚞𝚎 и 𝚏𝚊𝚕𝚜𝚎, выполнив все
дизъюнкты. Дизъюнкт является выполненным, если хотя бы один его
литерал имеет значение 𝚝𝚛𝚞𝚎. Например, чтобы выполнить формулу

(x1∨x⎯⎯2)∧(x⎯⎯1∨x⎯⎯3)∧(x1∨x2)∧(x⎯⎯3∨x4)∧(x⎯⎯1∨x4),

можно присвоить переменным x1, x2, x3, x4 значения 𝚝𝚛𝚞𝚎, 𝚏𝚊𝚕𝚜𝚎, 𝚏𝚊𝚕𝚜𝚎,
𝚝𝚛𝚞𝚎 (соответственно).

Постройте алгоритм, проверяющий, выполнима ли заданная формула, за
линейное от длины формулы время.

Указание: для каждого дизъюнкта (α∨β) проведите рёбра α⎯⎯→β и β⎯⎯→α во
вспомогательном графе.
