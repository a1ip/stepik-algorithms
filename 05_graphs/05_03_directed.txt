============================== Step 3 ==============================
Прямые ребра -- ребра от вершины к какому-то ее потомку
Обратные ребра -- ребра от вершины к предку
Перекрестные ребра -- связывают вершины, которые не являются ни
предком, ни потомком друг друга

============================== Step 4 ==============================
Лемма
Ориентированный граф содержит цикл тогда и только тогда, когда при
поиске в глубину обнаруживается обратное ребро.
u       v
()----->()

Если ребро является ребром дерева, то отрезки будут вложены
|=====| U
 |==| V

Для прямого ребра то же самое -- отрезки вложены

Обратное ребро:
|=====| V
 |==| U

Перекретстное ребро:
|=====| V |=====| U

Т.е. перекрестное ребро ведет в какую-то другую часть дерева
и не приводит к обнаружению новой вершины!

Поэтому для проверки на цикличность надо просто пройтись для каждого ребра
и посмотреть, не выполняется ли свойство, что отрезок для начала ребра
(т.е. для вершины u), вложен в отрезок для конца ребра.

Можно это обнаружить и в процессе работы!

Если при обработке вершины u, мы начали уже обрабатывать вершину
v. Если да -- подозрение на обратное ребро. Если для вершины v еще не
установлено время конца обработки, значит это ОБРАТНОЕ РЕБРО, надо
остановиться и выходя из рекурсии напечатать весь цикл.

============================== Step 5 ==============================
Задача на программирование. Дан ориентированный граф на n вершинах и m
рёбрах (1≤n,m≤1000). Необходимо вывести 1, если граф содержит цикл, и
0 в противном случае.

Sample Input:
4 4
1 2
4 1
2 3
3 1

Sample Output:
1

Source: loopd.py

============================== Step 6 ==============================
Топо Сортировка - расположить вершины так, чтобы все ребра шли слева
направо. Или упорядочить так, чтобы все ребра шли из вершины с меньшим
номером в вершину с большим номером.

============================== Step 7 ==============================
Лемма
Ориентированный граф может быть топологически упорядочен тогда и
только тогда, когда в нём нет циклов.

В графе без циклов есть хотя бы один исток и хотябы один сток.
Исток -- вершина, из которой ребра только выходят, но ничего не
входит. Сток -- вершина, в которую только входят ребра, но ничего не
выходит.

==============================Step 8 ==============================
Линейный алгоритм для топосортировки (без DFS)

TopSortIndegree

Для каждой вершины посчитаем входящую степень (сколько входящих
вершин) 

A B C D E F
0 1 1 3 1 2

Сначала запишем исток (A, где 0 входных вершин) и вычтем все выходящие
из истока вершины
Q -- очередь
Q: A

res = A

A B C D E F
0 1 0 3 0 1

Снова вычитаем все выходящие ребра из вершины C

Q: C,
res = A, C

A B C D E F
0 0 0 3 0 1

Q: E,
res = A, C, E

Q: B
res = A, C, E, B,

Q: F
res = A, C, E, B, F

Q: D
res = A, C, E, B, F, D

============================== Step 9 ==============================
Топосортировка на основе DFS

Лемма

В ориентированном ациклическом графе каждое ребро идёт из вершины с
бOльшим временем конца обработки в вершину с меньшим временем конца
обработки.

(u)--->(v)

u.finished > v.finished

1) explore(u) был сделан раньше, чем explore(v)

============================== Step 10 ==============================
Алгоритм топосорт на основе DFS
1) Запускаем DFS
2) Тем самым найдем finished для каждой вершины
3) Выпишем вершины в порядке уменьшения времени конца обработки
(finished)

Для примера на слайде 8/8

Вершина (discovered, finished), т.е. время начала и конца обработки
A(1, ) -> C(2, ) -> B(3, ) -> D(4, 5) впервые появилось время конца
обработки, поэтому добавляем элемент D в начало массива с результатом

В(3, 6)-> записываем B
С(2, 7)-> записываем С
E(8, ) -> F(9, 10)-> записываем F
E(8, 11)-> записываем E
A(1, 12)-> записываем A

Результат:
A, E, F, C, B, D

============================== Step 11 ==============================
Задача на программирование. Дан ациклический ориентированный граф на n
вершинах и m рёбрах (1≤n≤100000, 0≤m≤100000). Необходимо вывести n
чисел — номера вершин в порядке любой топологической сортировки.

Sample Input:
4 3
1 2
4 1
3 1

Sample Output:
4 3 1 2

Source: toposort.py

============================== Step 12 ==============================
Задача на peer-review. Путь в графе называется гамильтоновым, если он
проходит по каждой вершине графа ровно один раз. Постройте алгоритм,
проверяющий за время O(|V|+|E|), есть ли в заданном ориентированном
ациклическом графе гамильтонов путь. (Считаем, как обычно, что граф
дан списком смежности.)

Source: hamilton_peer.txt, toposort.py
