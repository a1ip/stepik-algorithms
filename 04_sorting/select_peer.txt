==================== Ответ препода ====================

Найдём за линейное время медиану, после чего разделим массив
относительно неё и рекурсивно перейдём в одну из частей (или закончим
работу, если нужная порядковая статистика уже нашлась). Поскольку
разделяемся относительно медианы, то гарантированно перейдём в часть,
размер которой хотя бы в два раза меньше размера исходного
массива. Этому соответствует рекуррентное соотношение
T(n)=T(n/2)+O(n), из которого следует, что T(n)=O(n).

==================== Мой ответ ====================

По условиям задачи мы имеем некий алгоритм, который находит медиану массива за линейное время. Пусть этот алгоритм оформлен в виде процедуры со следующей сигнатурой:

процедура MedianSelect(A[1..n], l, r)

процедура MedianSelect возвращает индекс медианы между элементами l и
r массива A.

Кроме того нам понадобится модифицированная процедура Partition(A[1..n], l, r, pivot) из алгоритма quicksort. Разница с оригинальной версией состоит в том, что мы явно передаем в параметрах, относительно какого элемента идет разбиение (pivot).

Используя эти две процедуры, опишем алгоритм, способный находить любую
заданную порядковую статистику массива также за линейное время:

I. Алгоритм

процедура QuickSelect(A[1..n], k)
  //Шаг 0. Условие выхода из рекурсии, либо ответ при длине массива 1
  если n == 1:
    вернуть A[1]
  //Шаг 1. Разбить исходный массив на массивы по 5 элементов
  разбить массив A на группу массивов $B_1, B_2, ..., B_{n/5}$ 
          длиной 5 элементов каждый, в том числе максимум одним массивом длиной $n \mod 5$
  //Шаг 2. Создать и заполнить массив M медиан каждого массива B
  для каждого массива в группе массивов $B_1, B_2, ..., B_{n/5}$:
    M <- MedianSelect(B_i, 1, 5)
  //Шаг 3. Найти индекс медианы массива М с медианами
  mm <- MedianSelect(M, 1, n/5)
  //Шаг 4. Разбиваем A относительно медианы медиан
  q = Partition(A[1..n], l, r, mm)
  //Шаг 5. Рекурсивно вызваться в соответствующей части массива
  если k < A[q]:
    QuickSelect(A[1..q - 1], k)
  иначе если k > A[q]:
    QuickSelect(A[q + 1..n], k)
  иначе если k = A[q]:
    вернуть A[q]

II. Доказательство линейного времени работы

Шаг 0 требует времени O(1), потому что это просто проверка.
Шаг 1 требует времени O(n), потому что для разбиения исходного массива на подмассивы достаточно один раз пробежаться по исходному.
Шаг 2 требует времени O(n) по условию задачи (MedianSelect работает за O(n) с n/5 кусочков константной длины 5).
Шаг 3 требует времени O(n) потому условию задачи.
Шаг 4 требует времени O(n) (доказательство в лекции про quicksort)
Шаг 5 максимум даст 7n/10 рекурсивных вызовов, потому что 3n/10 мы отсекли, когда искали медиану медиан.

3n/10 получается вот откуда: когда ищем медиану медиан (mm), половина от n/5 массивов B содержит по меньшей мере 3 элемента >= mm, кроме того B, где содержится сама mm и последней группы, которая недобирает 5 элементов (если она вообще есть). Так и получаем 3n/10:

$3\left ( \frac 1 2 \left ( \frac n 5 \right )\right ) = \frac {3n} {10}$

Тогда получаем такое рекуррентное соотношение:

T(n) = T(7n/10) + O(n)

Отсюда, по теореме получаем, что время работы алгоритма будет O(n), то есть линейным. $\blacksquare$
