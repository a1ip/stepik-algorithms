============================== Step 2 ==============================
процедура QuickSort(A,l,r) 
если l ≥ r:
  выйти
m ← Partition(A,l,r) // m называется разделителем или опорным
    		     // элементом (pivot)
QuickSort(A, l , m − 1) 
QuickSort(A, m + 1, r)

============================== Step 3 ==============================
Разделение за линейное время на месте
O(r -l + 1))

функция Partition(A,l,r) 
x ← A[l]
j←i
для i от l+1 до r:
  если A[i] ≤ x: 
    j←j+1
    обменять местами A[j] и A[i]
обменять местами A[l] и A[j] 
вернуть j

============================== Step 5 ==============================
Плохие и хорошие разделители

Разные варианты того: в каком мете будет разделитель

1) Ровно в середине
T(n) <= 2T(n/2) + O(n) -> T(n) = O(n log n)

2) В самом конце или в самом начале
T(n) <= T(n - 1) + O(n) -> T(n) = O(n^2)

3) Массив делится указателем на 1/8 и 7/8
T(n) <= T(n/8) + T(7n/8) + O(n) -> T(n) = O(n log n)

============================== Step 6 ==============================
Случайный разделитель

Выбираем случайным образом и меняем с первым элементом

============================== Step 7 ==============================
Оценка времени работы

Теорема
Пусть все ключи массива A[1 . . . n] различны. При случайном выборе
разделителя среднее время работы QuickSort(A) есть O(n log n). Время
работы в худшем случае есть O(n2).

Для алгоритмане бывает плохих входных массивов.
Проблема может быть только со случайным выбором разделителя (может
быть неудачный)

============================== Step 8 ==============================

1. Время работы пропорционально количеству сравнений (и количества элементов)
2. Любые два элемента сравнятся не более одного раза (время работы не
более чем n^2)
3. Сбалансированный разделитель это хорошо

============================== Step 10 ==============================
Если данные во входном массиве различны, то стандартный quicksort
Если данные очень похожи или много повторых, 3-way partition quicksort
(поддерживаем при выборе pivot не одну границу, а две: < x, == x, > x)

============================== Step 11 ==============================
Глубина рекурсии будет <= O(log n)

Хвостовая рекурсия -- это когда последний вызов процедуры является
вызов этой процедуры

Элиминация хвостовой рекурсии: глубина рекурсии O(log n) в худшем
случае

процедура QuickSort(A,l,r)
пока l < r:
  m ← Partition(A,l,r) 
  QuickSort(A, l , m − 1) // надо изменить так, чтобы сюда передавался
  	       	       	  // не левый кусок, а наиболее короткий из двух
  l←m+1

============================== Step 12 ==============================
Алгоритм introsort позволяет избежать сортировки за квадратичное время

============================== Step 13 ==============================
Задача на программирование. В первой строке задано два целых числа n и
m (1≤n≤50000, 1≤m≤50000) — количество отрезков и точек на прямой,
соответственно. Следующие n строк ввода содержат по два целых числа ai
и bi (ai≤bi) — координаты концов отрезков. Последняя строка содержит m
целых чисел -- координаты точек. Все координаты не превышают 105 по
модулю. Точка считается принадлежащей отрезку, если она находится
внутри него или на границе. Для каждой точки в порядке появления во
вводе выведите, скольким отрезкам она принадлежит.

Sample Input:
2 3
0 5
7 10
1 6 11

Sample Output:
1 0 0

Memory Limit: 256 MB

Time Limit: 5 seconds
0 / 5

Source: quicksort.py
