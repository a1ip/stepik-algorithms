============================== Step 2 ==============================
процедура MergeSort(A,l,r)
если l ≥ r: выйти
  m ← ⌊l+r ⌋ 2
Merge(MergeSort(A, l , m), MergeSort(A, m + 1, r ))

1) Вермя работы: O(n log n), т.к. по теореме о рекуррентных соотношениях
T(n) <= 2T(n/2) + O(n) => T(n) = O(n log n)

2) Дополнительная память: O(n)

3) Стабильный
============================== Step 5 ==============================

Нерекурсивный вариант
функция IterativeMergeSort(A[1...n])
Q ← [ ] {пустая очередь} для i от 1 до n:
  Inject(Q , [A[i ]]) 
пока |Q| > 1:
  Inject(Q , Merge(Eject(Q ), Eject(Q ))) вернуть Eject(Q)

============================== Step 6 ==============================
Тест. Рассмотрим следующую модификацию алгоритма сортировки слиянием:
разбиваем массив на три части примерно равного размера, рекурсивно
сортируем каждую из них, после чего сливаем три упорядоченные части в
одну (слить три части по-прежнему можно за время O(n)). Какова
асимптотика времени работы такого алгоритма?

Ответ: Θ(nlogn)
Потому что по теореме о рекуррентных соотношениях

T(n) = 3T(n/3) + O(n)
a = 3, b = 3, d = 1
T(n) = n^d log n = n log n

============================== Step 7 ==============================
Задача на программирование. Первая строка ввода содержит число n
(1≤n≤105), вторая — массив A[1…n], содержащий натуральные числа, не
превосходящих 109. Необходимо посчитать число пар индексов 1≤i<j≤n,
для которых A[i]>A[j]. (Такая пара элементов называются инверсией
массива. Количество инверсий в массиве является в некотором смысле его
мерой неупорядоченности: например, в упорядоченном по неубыванию
массиве инверсий нет вообще, а в массиве, упорядоченном по убыванию,
инверсию образуют каждые два элемента.)

Сроки сдачи задания:  

Sample Input:
5
2 3 9 2 9

Sample Output:
2

Source: mergesort.py
