============================== Step 3 ==============================

процедура HeapSort(A[1...n]) 
BuildMaxHeap(A) // строим max-heap с самым большим элементом в корне кучи
size ← n
для i от n до 2: // последовательно вытащить все максимумы из кучи в конец массива
  поменять местами A[i] и A[1] size ← size − 1
  SiftDown(A, 1)

============================== Step 4 ==============================
Построение кучи за линейное время

процедура BuildHeap(A[1...n]) 
для i от ⌈n/2⌉ до 1:
  SiftDown(A, i )

============================== Step 7 ==============================
Дан массив A[1…n], из элементов которого мы хотим сделать кучу. Каким
будет время работы (в худшем случае) построения кучи, если создать
пустую и кучу и последовательно добавить в неё все n элементов (то
есть на шаге i добавлять в кучу элемент A[i])? Отметьте все верные
варианты.

O(nlogn) 
Ω(n)
Ω(nlogn)
O(n2)

============================== Step 8 ==============================



Задача на программирование. Первая строка содержит число n
(1≤n≤100000), вторая — n натуральных чисел, не превышающих
109. Необходимо вывести упорядоченную по неубыванию последовательность
этих чисел (числа должны быть разделены пробелами).

Sample Input:
5
2 3 9 2 9

Sample Output:
2 2 3 9 9

Memory Limit: 256 MB
Time Limit: 5 seconds 

Source: heapsort.py

============================== Step 9 ==============================

Задача повышенной сложности для самостоятельной проверки. Даны два
упорядоченных по неубыванию массива A[1…n] и B[1…n]. Необходимо
напечатать все суммы вида A[i]+B[j] в порядке неубывания. Для этого
можно предварительно записать все такие суммы в массив размера n2,
после чего просто отсортировать его. Время работы такого решения будет
O(n2logn), используемая память — O(n2). Постройте алгоритм с таким же
(асимптотически) временем работы и линейной памятью.

