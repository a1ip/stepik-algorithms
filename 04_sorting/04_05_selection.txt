============================== Step 2 ==============================
Линейное в среднем время

// надо было бы расписать как в quicksort (A, l, r, k)
функция RandomSelect(A[1...n],k) // 1 <= k <= n
если n = 1:
  вернуть A[1]
разбить A относительно случайного элемент // m
рекурсивно вызваться для соответствующейчасти

m -- индекс, возвращаемый процедурой partition
x -- значение массива в индексе m
если k < m, тогда рекурсия на левой части
если k = m, просто возвращаем x
если k > m, тогда рекурсия на правой части

============================== Step 4 ==============================
Лемма

Математическое ожидание количества подбрасываниий монетки до первой
решки (включительно) равно 2.

============================== Step 5 ==============================

Оценка времени работы

T(n) <= T(3n/4) + T(n->3n/4)

n->3n/4 - переход массива от длины n к длине 3n/4
E(n) - время работы в среднем

E(n) <= E(3n/4) + O(n) -> E(n) = O(n)

============================== Step 6 ==============================
Задача на peer-review. Предположим, что в нашем распоряжении есть
алгоритм, который за линейное время находит медиану массива. Алгоритм
не изменяет массив и выдает индекс ячейки исходного массива, в которой
стоит медиана. Покажите, как использовать этот алгоритм, чтобы за
линейное же время найти любую заданную порядковую статистику массива.

Срок сдачи задания: до Soft дедлайна (20.10.2014 23:59 MSK)

Обратите внимание на изменения в правилах сдачи задач на peer review.

Source: select_peer.txt


============================== Step 7 ==============================

функция Select(A[1...n],k) 
если n = 1: 
  вернуть A[1]

разбить A на n/5 массивов B1, . . . , Bn/5 длины 5 
m1,...,mn/5 ← медианы массивов B1,...,Bn/5  // отсортировать и взять элемент по середине
M ← [m1,...,mn/5]
x ← Select(M,n/10) {медиана медиан}
разбить A относительно x
рекурсивно вызваться для соответствующей части

Линейное время потому что:
1) относительно x массив разобьется сбалансированно
2) 

          x      
T(n) ≤ T(n/5) + T(7n/10) + O(n)

основной теоремой о рекуррентных соотношений нельзя воспользоваться,
потому что размеры двух массивов, которые получаются, они разные. по теореме должны быть равные

сортировка кусочков n/5 - кусочки константной длины, поэтому сортировка идет за константу,
поэтому все кусочки отсортируются за линейное время

массив из медиан передается в рекурсивный вызов - это тоже все за линейное время

Дерево рекурсий:   |     Работа на каждом уровне
      n            |    c * n
2n/10,  7n/10      |    c * 9n/10
4n/100  14n/100    |    c* 81n/100

Во всей работе по уровням -- будет убывающая геометрическая прогрессия
(оценивается как константа), c * n вынесется -> поэтому время работы линейное
 
### Доказательство линейности времени по индукции

Пусть есть константа альфа, что
T(n) <= alpha n

База индукции: n = 1, alpha достаточно большого значения

Переход: T(n) ≤ T(n/5) + T(7n/10) + c*n <= alpha n / 5 + 7 alpha n / 10 + c*n ? <= ? alpha n <=>

9 alpha / 10 + c <= alpha <=> c <= alpha / 10

Если взят alpha =  10c, то неравенство будет выполнено
Т.е. при достаточно большом значении альфа

QED

Почему мы в алгоритме делили на кусочка по 5?

Т.к. 5 это минимальная константа, при которой гарантируется, что будет
выполнено рекуррентное соотношение наверху.

Если бы мы взяли 3, то время работы было бы порядка n log n

На нужно было, чтобы на каждом уровне дерева рекурсий, тратилось бы время
с убывающей геом прогрессий. Иначе мы бы на каждом уровне тратили n log n

Если бы делили на 4, пришлось бы договариваться, какой элемент надо
считать медианой (2-й или 3-й). И 7n/10

Особенности этого алгоритма:
1) Сложный код
2) На практике работает медленнее, чем первый
3) Но зато линейное время в худшем случае на поиск любой порядковой статистики
4) Можно встроить его в алгоритм quicksort для поиска точки разбиения, тогда все разбиения
будут сбалансированы и время квиксорта будет n log n в худшем случае (но это непрактично)


