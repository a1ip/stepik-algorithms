============================== Step 8 ==============================
Тест. Рассмотрим три алгоритма.

    Алгоритм 1, решая задачу, производит пять рекурсивных вызовов для
    подзадач вдвое меньшего размера, после чего строит ответ для
    исходной задачи за линейное время.

    Алгоритм 2, решая задачу размера n, делает два рекурсивных вызова
    для задач размера n−1, после чего находит ответ за время O(1).

    Алгоритм 3, решая задачу размера n, рекурсивно решает девять задач
    размера n/3 и строит ответ за время O(n2).

Упорядочите данные три алгоритма в порядке увеличения скорости роста
времени работы (формат ответа: "2 3 1").

Сроки сдачи задания:  

Soft дедлайн 06.10.2014 23:59 MSK 

Hard дедлайн 13.10.2014 23:59 MSK

Ответ: 3 1 2

a1 -> O(n^(log_2 5))
a2 -> O(2^n)
a3 -> O(n^2)

============================== Step 9 ==============================

Задача на программирование. Дано натуральное число 1≤n≤105 и массив
целых чисел A[1…n], не превосходящих по модулю 109. Необходимо вывести
1, если в массиве A есть число, встречающееся строго больше n/2 раз, и
0 в противном случае.

Сроки сдачи задания:  
Soft дедлайн 06.10.2014 23:59 MSK 
Hard дедлайн 13.10.2014 23:59 MSK

Sample Input:
5
2 3 9 2 2

Sample Output:
1

Memory Limit: 256 MB
Time Limit: 5 seconds

Source: array.py

============================== Step 10 ==============================


Задача на peer-review. Дан упорядоченный по возрастанию массив
различных целых чисел A[1…n]: A[1]<A[2]<…<A[n]. Покажите, как
проверить за время O(logn), найдётся ли такое i, что A[i]=i.

Срок сдачи задания — до Soft дедлайна (06.10.2014 23:59)

============================== Step 11 ==============================
Задача для самостоятельной проверки. Рассмотрим рекуррентное
соотношение T(n)≤T(n/3)+T(2n/3)+O(n). Воспользоваться для него
основной теоремой о рекуррентных соотношениях не получится, потому что
в данном случае задача разбивается на две подзадачи разного
размера. Тем не менее, несложно показать, что T(n)=O(nlogn). Для этого
достаточно проанализировать дерево рекурсии — точно так же, как и в
доказательстве основной теоремы. Разница будет лишь в том, что дерево
теперь не будет сбалансированным: длина его самой короткой ветки будет
равна log3n, а самой длинной — log3/2n. Восстановите все недостающие
детали доказательства самостоятельно.


Докажите также, что из рекуррентного соотношения
T(n)≤T(n/20)+T(17n/20)+O(n) следует, что T(n)=O(n).

============================== Step 12 ==============================



Задача для самостоятельной проверки. Мы анализировали рекуррентные
соотношения, оценивая число операций на каждом уровне дерева
рекурсии. Примерно тот же анализ можно изложить иначе. Для примера
рассмотрим знакомое нам соотношение T(n)=2T(n/2)+O(n) и будем его
"раскручивать". Первым делом заменим O(n) на верхнюю оценку cn для
некоторой константы c, получив T(n)≤2T(n/2)+cn. Применяя это
неравенство несколько раз, мы оцениваем T(n) сначала через T(n/2),
потом через T(n/4), через T(n/8) и так далее. В конце концов мы дойдём
до T(1)=O(1):

Уже виден и общий вид такого неравенства:
T(n)≤2kT(n2k)+kcn. Подставляя k=log2n, получаем
T(n)≤nT(1)+cnlog2n=O(nlogn).

    Проведите те же рассуждения для T(n)=3T(n/2)+O(n). Каков будет
    общий вид неравенства в данном случае? Какое k нужно подставить?
    Теперь оцените T(n), если T(n)=T(n−1)+O(1) (это соотношение не
    покрывается нашей теоремой).

============================== Step 13 ==============================


Задача повышенной сложности для самостоятельной проверки. Локальным
минимумом матрицы называется элемент, значение которого не превосходит
значений всех его соседей (считаем, что у внутреннего элемента матрицы
четыре соседа, у элементы на границе — три, а у углового элемента —
два). Постройте алгоритм, который по данной матрице размера n×n,
содержащей различные натуральные числа, находит (любой) локальный
минимум за время O(n) (такое время называется сублинейным, поскольку
оно по порядку меньше размера входа).

