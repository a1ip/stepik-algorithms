#!/usr/local/bin/python3

"""
Не понял причём тут "разделяй и влавствуй". Конечно за уши можно
притянуть, но эта задача и без этого решается двумя проходами по
массиву и с O(1) дополнительной памяти.

Справедливо. Однако, интересно то, что если разрешено изменять массив
(т.е. упорядочивать in-place), то версии и с сортировкой, и с
Selection algorithm (использовал реализацию std::nth_element из C++)
работают быстрее этого 2-х проходного алгоритма примерно на
20-50%.Тестировал на массивах из 10^9 int'ов. Массивы были разной
степени упорядоченности. 

В принципе эта задаче решается за O(n) (см. комментарий от
@Vladimir_Skipor).Можно предложить рекурсивный алгоритм, работающий за
O(n log n).Он может быть основан на следующем наблюдении.Элемент,
встречающийся строго больше n/2 раз, назовём доминирующим, тогда если
в массиве есть доминирующий элемент, то хотя бы в одной "половине" от
исходного массива этот элемент также будет доминирующим (это несложно
доказать методом "от противного").По сути рекурсивный переход у вас
есть. Осталось придумать как "склеивать" частичные решения. 

"""


line1 = input()
line2 = input()
n = int(line1)
A = [int(x) for x in line2.split()]

def counter(arr, n):
    maximum = n /2
    for i in arr:
        if (arr.count(i) > maximum):
            return 1
    return 0


def occur(items):
    d = {}
    for i in items:
        if i in d:
            d[i] = d[i]+1
        else:
            d[i] = 1
    return d

def counter2(A, n):
    maximum = n / 2
    for i in occur(A).values():
        if (i > maximum):
            return 1
    return 0

print(counter2(A, n))
