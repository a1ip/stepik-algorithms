Из теоремы о рекуррентных соотношениях можно предположить, что алгоритм, работающий за время O(log n), 
может производить один рекурсивный вызов для подзадачи вдое меньшего размера и дает ответ для исходной задачи
за время O(1): T(n) = T(n / 2) + O(1)

Таким алгоритмом может быть процедура, которая разбивает входной
массив надвое на каждой итерации и, если в данном куске находится
искомый элемент, сразу за (константное время) дает ответ. То есть
никаких затрат на "склейку" результатов каждой операции не требуется.

В качестве такого алгоритма можно предложить несколько модифицированную версию алгоритма бинарного поиска, 
время выполнения которого доказано как O(log n):

процедура IndexEqualsValue(A[1..n])
{массив А упорядочен, так что A[1] < A[2] < ... < A[n]}

l <- 1, r <- n
пока l <= r:
  m <- [l + r] // 2
  если A[m] == m: вернуть истина
  иначе если A[m] > m: r <- m - 1
  иначе если A[m] < m: l <- m + 1
вернуть ложь

Если во входном массиве n элементов, то после первой итерации алгоритм (если не найдет ответа сразу)
будет оперировать максимум с n/2 элементами, после второй n/4, далее  n/8, и так далее.
Даже если искомый элемент не будет найден (худший случай), алгоритм отработает $log_2 (n) + 1$ итераций.
Записывая эту производительность в О-нотации, основание логарифма и константа 1 не учитываются,
и получаем время O(logn). QED.
